package org.metaborg.sdf2table.parsetable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;

import org.metaborg.sdf2table.core.Benchmark;
import org.metaborg.sdf2table.grammar.Exportable;
import org.metaborg.sdf2table.grammar.Production;
import org.metaborg.sdf2table.grammar.Trigger;
import org.metaborg.sdf2table.symbol.Terminal;
import org.spoofax.interpreter.terms.IStrategoTerm;
import org.spoofax.terms.StrategoAppl;
import org.spoofax.terms.StrategoConstructor;
import org.spoofax.terms.StrategoInt;

/**
 * Parse table state.
 */
public class State implements Exportable{
	static Benchmark.DistributedTask _t_shift;
	static Benchmark.DistributedTask _t_close;
	static Benchmark.DistributedTask _t_action;
	static Benchmark.DistributedTask _t_equal;
	
	public static void reset(){
		_t_shift = _t_close = _t_action = _t_equal = null;
	}
	
	/**
	 * Some Stratego constructors.
	 */
	private static final StrategoConstructor CONS_STATE_REC = new StrategoConstructor("state-rec", 3);
	private static final StrategoConstructor CONS_ACTION = new StrategoConstructor("action", 2);
	private static final StrategoConstructor CONS_GOTO = new StrategoConstructor("goto", 2);
	
	/**
	 * The parse table containing the state.
	 */
	private ParseTable _pt;
	
	/**
	 * Item set.
	 */
	private ItemSet _items;
	
	/**
	 * Unique identifier of the state.
	 * <p>
	 * This identifier is supposed to be generated by the parse table via the method
	 * {@link #assignId(int)} when the state is added to the table.
	 */
	private int _id;
	
	/**
	 * An List<Action> factory used to populate the _actions table.
	 */
	private static class ActionListConstructor implements CollectionConstructor<List<Action>, Action>{
		public List<Action> create(){
			return new LinkedList<>();
		}
		
		public List<Action> create(List<Action> other){
			return new LinkedList<>(other);
		}
	}
	
	/**
	 * Static instance of the List<Action> factory.
	 */
	private static final ActionListConstructor _constructor = new ActionListConstructor();
	
	/**
	 * List of actions 
	 */
	MergingMap<Trigger, List<Action>, Action> _actions = new MergingMap<>(_constructor);
	
	/**
	 * Create a new empty state.
	 * @param pt The parse table containing the state.
	 */
	public State(ParseTable pt){
		_pt = pt;
		_items = new ItemSet();
		_id = -1;
	}
	
	/**
	 * Create a new state from an already existing item set.
	 * @param pt The parse table containing this state.
	 * @param set An item set.
	 */
	public State(ParseTable pt, ItemSet set){
		_pt = pt;
		_items = set;
		_id = -1;
	}
	
	/**
	 * Unique identifier of the state.
	 * <p>
	 * This identifier is generated by the parse table when the state is added to it.
	 * @return An id for this state.
	 */
	public int id(){
		return _id;
	}
	
	/**
	 * This method assign an id to the state. It should only be called by the parse table.
	 * @param id
	 */
	public void assignId(int id){
		if(_id == -1)
			_id = id;
	}
	
	/**
	 * Close the associated item set.
	 * <p>
	 * This method add each item of the item set closure to the state,
	 * generate every reduce actions associated to those items.
	 */
	@SuppressWarnings("unchecked")
	public void close(){
		if(_t_close == null)
			_t_close = Benchmark.newDistributedTask("State.close");
		_t_close.start();
		
		_items = _items.closure();
		
		/*Map<Production, Map<Reduce.ReducePolicy, Reduce>> reduces = new HashMap<>();
		
		for(Item i : _items){
			for(Reduce r : i.reduceActions()){
				//Reduce reduce = reduces.get(r.getProduction());
				Map<Reduce.ReducePolicy, Reduce> map = reduces.get(r.getProduction());
				if(map == null)
					reduces.put(r.getProduction(), map = new EnumMap<>(Reduce.ReducePolicy.class));
				Reduce reduce = map.get(r.policy());
				if(reduce == null)
					map.put(r.policy(), r);
				else
					map.put(r.policy(), new Reduce(reduce.getTriggerTerminal().union(r.getTriggerTerminal()), r.getProduction()));
				
			}
		}
		
		for(Entry<Production, Map<Reduce.ReducePolicy, Reduce>> e : reduces.entrySet()){
			for(Entry<Reduce.ReducePolicy, Reduce> re : e.getValue().entrySet()){
				addAction(re.getValue());
			}
		}*/
		
		for(Item i : _items){
			addActions((Set<Action>)(Object)i.reduceActions());
		}
		
		_t_close.stop();
	}
	
	/**
	 * Generate every shift and accept actions associated with this state,
	 * and generate the associated states (for shift actions).
	 * Called on the initial state, this method generate the complete
	 * parse graph.
	 * <p>
	 * Be sure to call {@link #close()} before this method to get a consistent state.
	 */
	public void shift(){
		if(_t_shift == null)
			_t_shift = Benchmark.newDistributedTask("State.shift");
		_t_shift.start();
		
		//Map<Trigger, ItemSet> map = _items.shift();
		MergingMap<Trigger, ItemSet, Item> map = _items.shift();
		
		_t_shift.stop();
		
		for(Entry<Trigger, ItemSet> e : map.entrySet()){
			State s = new State(_pt, e.getValue());
			
			if(s.isAcceptState())//{
				addAction(new Accept(e.getKey()));
			//}else{
				s = _pt.addState(s); // state s may change here
				addAction(new Shift(e.getKey(), s));
			//}
		}
	}
	
	/**
	 * @return The item set of the state.
	 */
	public ItemSet items(){
		return _items;
	}
	
	/**
	 * Add an item to the state.
	 * @param item An item.
	 */
	public void addItem(Item item){
		_items.add(item);
	}
	
	/**
	 * Add an action to the state.
	 * <p>
	 * If the trigger symbol of the action is a character and intersects some other already defined actions,
	 * this action will be added multiple times: first for each intersection of character class, 
	 * and also for the complementary of those intersections (if any).
	 * @param a An action.
	 */
	private void addAction(Action a){
		if(_t_action == null)
			_t_action = Benchmark.newDistributedTask("State.ation");
		_t_action.start();
		
		_actions.put(a.trigger(), a);
		
		_t_action.stop();
	}
	
	/**
	 * Add a collection of action to the state.
	 * <p>
	 * See {@link #addAction(Action)}.
	 */
	private void addActions(Collection<Action> c){
		for(Action a : c){
			addAction(a);
		}
	}
	
	/**
	 * A state is an "accept state" iff it contains a final item which produce the <FileStart> symbol.
	 * @return true if this state is an "accept state".
	 */
	public boolean isAcceptState(){
		for(Item i : _items){
			if(i.isFinal() && i.production().product().isFileStart())
				return true;
		}
		
		return false;
	}
	
	@Override
	public String toString(){
		return "{"+_items.toString()+"}";
	}
	
	@Override
    public boolean equals(Object o){
		if(o != null && o instanceof State){
			if(_t_equal == null)
				_t_equal = Benchmark.newDistributedTask("State.equal");
			_t_equal.start();
			
			State s = (State)o;
			boolean ok = s._items.equals(_items);
			_t_equal.stop();
			return ok;
		}
		return false;
    }

    @Override
    public int hashCode() {
        return _items.hashCode();
    }
    
    public IStrategoTerm toATerm(){
    	List<IStrategoTerm> gotos = new ArrayList<>();
    	List<IStrategoTerm> actions = new ArrayList<>();
    	
    	for(Entry<Trigger, List<Action>> entry : _actions.entrySet()){
    		if(entry.getKey() instanceof Terminal){
	    		Terminal trigger = (Terminal)entry.getKey();
	    		
				List<IStrategoTerm> alist = new ArrayList<>();
				
				for(Action a : entry.getValue()){
		    		alist.add(a.toATerm());
		    		
		    		// TODO Shift gotos: is that usefull ?
	    			if(a instanceof Shift){
	    				gotos.add(new StrategoAppl(
		    					CONS_GOTO,
		    					new IStrategoTerm[]{
		    							Utilities.strategoListFromCollection(((Terminal)trigger).getATermCC()),
		    							new StrategoInt(((Shift)a).getDestination().id(), null, 0)
								},
		    					null,
		    					0
						));
	    			}
	    		}
				
				actions.add(new StrategoAppl(
						CONS_ACTION,
						new IStrategoTerm[]{
								Utilities.strategoListFromCollection(((Terminal)trigger).getATermCC()),
								Utilities.strategoListFromCollection(alist)
						},
						null,
						0
				));
    		}else{
    			Production trigger = (Production)entry.getKey();
    			
    			for(Action a : entry.getValue()){
    				if(a instanceof Shift){
    					Shift s = (Shift)a;
    					
    					gotos.add(new StrategoAppl(
		    					CONS_GOTO,
		    					new IStrategoTerm[]{
		    							Utilities.strategoListFromArray(new StrategoInt(trigger.id(), null, 0)),
		    							new StrategoInt(s.getDestination().id(), null, 0)
								},
		    					null,
		    					0
						));
    				}
        		}
    		}
    	}
    	
    	return new StrategoAppl(
    			CONS_STATE_REC,
    			new IStrategoTerm[]{
    					new StrategoInt(id(), null, 0),
    					Utilities.strategoListFromCollection(gotos),
    					Utilities.strategoListFromCollection(actions)
    			},
    			null,
    			0
		);
    }
	
	public String digraph(){
		String str = "\"node"+String.valueOf(_id)+"\" [margin=0 \n";
		str += "label = <<table border=\"0\" cellpadding=\"4\" cellspacing=\"0\"><tr><td border=\"1\" sides=\"B\">";
		str += "State "+String.valueOf(_id)+"</td></tr>";
		
		for(Item i : _items){
			str += "<tr border=\"1\">";
			str += i.digraph();
			str += "</tr>";
		}
		
		str += "</table>>\n";
		str += "shape = \"record\"\n";
		str += "];\n";
		
		int k = 0;
		for(Entry<Trigger, List<Action>> e : _actions.entrySet()){
			Trigger trigger = e.getKey();
			String color = "";
			String label_color = "";
			
			str += "\"node_accept\" [label = \"accept\"];\n";
			String conflict_node = null;
			
			if(e.getValue().size() > 1)
				color = " color=\"red\"";
			for(Action a : e.getValue()){
				String start = "node"+String.valueOf(_id);
				String label = Utilities.toLabel(trigger.toString());
				String end = "";
				
				if(a instanceof Shift){
					Shift s = (Shift)a;
					end = "node"+String.valueOf(s.getDestination().id());
				}else if(a instanceof Reduce){
					Reduce r = (Reduce)a;
					end = "node"+String.valueOf(_id)+"_"+String.valueOf(r.getProduction().id());
					start = end+"\" [label = \""+Utilities.toLabel(r.getProduction().toString())+"\"];\n\""+start;
				}else if(a instanceof Accept){
					end = "node_accept";
					if(e.getValue().size() == 2)
						color = "";
				}
				
				if(e.getValue().size() > 1){
					if(conflict_node == null){
						conflict_node = "node_conflict_"+String.valueOf(_id)+"_"+String.valueOf(k++);
						str += "\""+conflict_node+"\" [shape=diamond,style=filled,label=\"\",height=.1,width=.1];\n";
						str += "\""+start+"\" -> \""+conflict_node+"\" [label=\""+label+"\""+color+label_color+"];\n";
					}
					str += "\""+conflict_node+"\" -> \""+end+"\" [label=\"\""+color+label_color+"];\n";
				}else
					str += "\""+start+"\" -> \""+end+"\" [label=\""+label+"\""+color+label_color+"];\n";
			}
		}
		
		return str;
	}
}