package org.metaborg.sdf2table.grammar;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.metaborg.sdf2table.parsetable.Priority;
import org.metaborg.sdf2table.parsetable.Utilities;
import org.metaborg.sdf2table.symbol.Symbol;
import org.metaborg.sdf2table.symbol.SymbolCollection;
import org.metaborg.sdf2table.symbol.Terminal;
import org.spoofax.interpreter.terms.IStrategoAppl;
import org.spoofax.interpreter.terms.IStrategoTerm;
import org.spoofax.terms.StrategoAppl;
import org.spoofax.terms.StrategoConstructor;
import org.spoofax.terms.StrategoInt;
import org.spoofax.terms.StrategoList;
import org.spoofax.terms.StrategoString;

/**
 * Grammar production.
 * 
 */
public class Production extends Follower implements Exportable, Trigger{
	private static int _count = 0;
	
	public static void reset(){
		_count = 0;
	}
	
	/**
	 * Some Stratego constructors for the ATerm translation.
	 */
	private static final StrategoConstructor CONS_LABEL = new StrategoConstructor("label", 2);
	private static final StrategoConstructor CONS_PROD = new StrategoConstructor("prod", 3);
	private static final StrategoConstructor CONS_NO_ATTRS = new StrategoConstructor("no-attrs", 0);
	private static final StrategoConstructor CONS_ATTRS = new StrategoConstructor("attrs", 1);
	private static final StrategoConstructor CONS_ATTR_LEFT = new StrategoConstructor("left", 0);
	private static final StrategoConstructor CONS_ATTR_RIGHT = new StrategoConstructor("right", 0);
	private static final StrategoConstructor CONS_ATTR_BRACKET = new StrategoConstructor("bracket", 0);
	private static final StrategoConstructor CONS_ATTR_REJECT = new StrategoConstructor("reject", 0);
	private static final StrategoConstructor CONS_ATTR_LONGEST_MATCH = new StrategoConstructor("longest-match", 0);
	
	private static final StrategoConstructor CONS_TERM = new StrategoConstructor("term", 1);
	private static final StrategoConstructor CONS_CONS = new StrategoConstructor("cons", 1);
	
	/**
	 * Production attributes.
	 */
	public enum Attribute{
		ASSOC_LEFT,
		ASSOC_RIGHT,
		
		BRACKET,
		REJECT,
		
		LONGEST_MATCH
	}
	
	/**
	 * Unique identifier of the production.
	 */
	int _id = -1;
	
	/**
	 * Symbol synthesized by the production.
	 */
	Symbol _symbol;
	
	/**
	 * Constructor name, if any.
	 */
	String _cons = null;
	
	/**
	 * Attributes of the production.
	 */
	List<Attribute> _attributes;
	
	/**
	 * List of symbols of the production. From left to right.
	 */
	List<Symbol> _rhs;
	
	/**
	 * List the priorities where this production is the direct ascendant.
	 */
	Set<Priority> _priorities = new HashSet<>();
	
	/**
	 * FOLLOW(this).
	 * <p>
	 * This set is not computed until {@link Syntax#computeFollowSets()} has not been called.
	 */
	FollowSet _follow_set = new FollowSet(this);
	
	/**
	 * String representation of the production.
	 * <p>
	 * This attribute is computed when {@link #toString()} is first called to avoid multiple computation of the same value.
	 * <p>
	 * The string value is also used to compute the {@link #hashCode()}.
	 */
	String _str;
	
	/**
	 * Main constructor.
	 * @param symbol The symbol produced by the production.
	 * @param cons The name of the constructor. May be null is the production have no constructor defined.
	 * @param rhs A list of symbols that compose the production, from left to right.
	 * @param attributes A list of attributes.
	 */
	public Production(Symbol symbol, String cons, List<Symbol> rhs, List<Attribute> attributes){
		_symbol = symbol;
		_rhs = rhs;
		_cons = cons;
		_attributes = attributes;
	}
	
	/**
	 * Get the list of priorities.
	 * @return The list the priorities where this production is the direct ascendant.
	 */
	public Set<Priority> priorities(){		
		return _priorities;
	}
	
	/**
	 * Compute direct dependencies generated by this production.
	 * <p>
	 * For a production P = "A0 A1 ... An -> B", the set of direct dependencies is decided as follow:
	 * 
	 * 1. if P is empty then FIRST(P) depends on FOLLOW(P).
	 * 2. if A0 if a non-terminal then for all production Q that produce A0 and does not conflict P at position 0, FIRST(P) depends on FIRST(Q).
	 * 3. for all Ai of P,
	 * 		if i < n then for all production Q that produce Ai+1 and does not conflict P at position i+1, FOLLOW(Ai) depends on FIRST(Q).
	 * 		if i = n then FOLLOW(Ai) depends on FOLLOW(P).
	 */
	public void computeDependencies(){
		// FIRST(this) dependencies
		if(_rhs.isEmpty()){
			addDependency(_follow_set);
		}else{
			Symbol sym = _rhs.get(0);
			
			if(sym instanceof Terminal){
				addFirst((Terminal)sym);
			}else{
				for(Production p : sym.getProductions()){
					if(!conflicts(p, 0))
						addDependency(p);
				}
			}
		}
		
		// for all Xi, FOLLOW(Xi) dependencies
		for(int i = 0; i < _rhs.size(); ++i){
			Symbol sym = _rhs.get(i);
			if(!sym.isTerminal()){
				Symbol next = null;
				if(i+1 < _rhs.size())
					next = _rhs.get(i+1);
				
				for(Production sp : sym.getProductions()){
					if(!conflicts(sp, i)){
						if(next == null){
							sp.followSet().addDependency(_follow_set);
						}else{
							if(next instanceof Terminal){
								sp.followSet().addFirst((Terminal)next);
							}else{
								for(Production np : next.getProductions()){
									if(!conflicts(np, i+1)){
										sp.followSet().addDependency(np);
									}
								}
							}
						}
					}
				}
			}
		}
	}
	
	/**
	 * FOLLOW(this).
	 * <p>
	 * This set is computed by calling the method {@link Syntax#computeFollowSets()} on the corresponding syntax instance.
	 * Before that, the set is empty.
	 * @return FOLLOW(this)
	 */
	public FollowSet followSet(){
		return _follow_set;
	}
	
	/**
	 * @return The last symbol of the production, or null if the production is empty.
	 */
	public Symbol lastSymbol(){
		if(_rhs.isEmpty())
			return null;
		return _rhs.get(_rhs.size()-1);
	}
	
	/**
	 * 
	 * @param prod A symbol production.
	 * @param pos The position in the production.
	 * @return true if it is not possible to use the production {@code prod} to expend the symbol at position {@code pos}.
	 */
	public boolean conflicts(Production prod, int pos){
		if(pos >= _rhs.size())
			return false;
		Symbol next = _rhs.get(pos);
		if(prod.product().equals(next)){
			for(Priority prio : _priorities){
				if(prio.hasHigherPriority(prod, pos))
					return true;
			}
		}
		return false;
	}
	
	/**
	 * Declare priority.
	 * <p>
	 * This method should not be directly used.
	 * @param prio
	 */
	public boolean addPriority(Priority prio){
		return _priorities.add(prio);
	}
	
	/**
	 * List of attributes.
	 * @return A list of attributes.
	 */
	public List<Attribute> attributes(){
		return _attributes;
	}
	
	/**
	 * Synthesized symbol.
	 * @return The symbol resulting of the production.
	 */
	public Symbol product(){
		return _symbol;
	}
	
	/**
	 * Symbols defining the production.
	 * @return A list of symbols defining the production, from left to right.
	 */
	public List<Symbol> symbols(){
		return _rhs;
	}
	
	/**
	 * Production constructor.
	 * @return The name of the constructor is any, null otherwise.
	 */
	public String constructor(){
		return _cons;
	}
	
	/**
	 * Unique identifier of the production.
	 * <p>
	 * This identifier is generated when this method is called for the first time.
	 * @return An integer associated with this production.
	 */
	public int id(){
		if(_id == -1)
			_id = 257+_count++;
		return _id;
	}
	
	@Override
	public boolean equals(Object o){
		if(o != null && o instanceof Production){
			Production p = (Production)o;
			if(p._symbol.equals(_symbol) && p._rhs.size() == _rhs.size() && p._attributes.size() == _attributes.size()){
				for(int i = 0; i < _rhs.size(); ++i){
					if(!_rhs.get(i).equals(p._rhs.get(i)))
						return false;
				}

				for(int i = 0; i < _attributes.size(); ++i){
					if(!_attributes.get(i).equals(p._attributes.get(i)))
						return false;
				}
				
				return true;
			}
		}
		return false;
	}
	
	@Override
	public String toString(){
		if(_str == null){
			_str = "";
			for(Symbol s : _rhs)
				_str += s.toString()+" ";
			_str += "â†’ "+_symbol.toString();
			if(_cons != null && !_cons.isEmpty())
				_str += "."+_cons;
			if(!_attributes.isEmpty()){
				int i = 0;
				_str += " {";
				for(Attribute attr : _attributes){
					if(i > 0)
						_str += ",";
					switch(attr){
					case ASSOC_LEFT:
						_str += "left";
						break;
					case ASSOC_RIGHT:
						_str += "right";
						break;
					case BRACKET:
						_str += "bracket";
						break;
					case REJECT:
						_str += "reject";
						break;
					case LONGEST_MATCH:
						_str += "longest-match";
						break;
					}
					++i;
				}
				_str += "}";
			}
		}
		
		return _str;
	}
	
	@Override
    public int hashCode() {
        return toString().hashCode();
    }
	
	public IStrategoTerm toATerm(){
		IStrategoTerm[] list = new IStrategoTerm[_rhs.size()];
		for(int i = 0; i < _rhs.size(); ++i)
			list[i] = _rhs.get(i).toATerm();
		
		IStrategoTerm attrs = null;
		if(_attributes.isEmpty() && (_cons == null || _cons.isEmpty())){
			attrs = new StrategoAppl(CONS_NO_ATTRS, new IStrategoTerm[]{}, null, 0);
		}else{
			IStrategoTerm[] attr_list = new IStrategoTerm[_attributes.size()+1];
			
			for(int i = 0; i < _attributes.size(); ++i){
				switch(_attributes.get(i)){
				case ASSOC_LEFT:
					attr_list[i] = new StrategoAppl(CONS_ATTR_LEFT, new IStrategoTerm[]{}, null, 0);
					break;
				case ASSOC_RIGHT:
					attr_list[i] = new StrategoAppl(CONS_ATTR_RIGHT, new IStrategoTerm[]{}, null, 0);
					break;
				case BRACKET:
					attr_list[i] = new StrategoAppl(CONS_ATTR_BRACKET, new IStrategoTerm[]{}, null, 0);
					break;
				case REJECT:
					attr_list[i] = new StrategoAppl(CONS_ATTR_REJECT, new IStrategoTerm[]{}, null, 0);
					break;
				case LONGEST_MATCH:
					attr_list[i] = new StrategoAppl(
							CONS_TERM,
							new IStrategoTerm[]{
									new StrategoAppl(CONS_ATTR_LONGEST_MATCH, new IStrategoTerm[]{}, null, 0)
							},
							null,
							0
						);
					break;
				}
			}
			
			if(_cons != null && !_cons.isEmpty()){
				attr_list[attr_list.length-1] = new StrategoAppl(
						CONS_TERM,
						new IStrategoTerm[]{
								new StrategoAppl(
										CONS_CONS,
										new IStrategoTerm[]{new StrategoString(_cons, null, 0)},
										null,
										0)
						},
						null,
						0);
			}
			
			attrs = new StrategoAppl(CONS_ATTRS, new IStrategoTerm[]{Utilities.strategoListFromArray(attr_list)}, null, 0);
		}
		
		return new StrategoAppl(
				CONS_LABEL,
				new IStrategoTerm[]{
						new StrategoAppl(
							CONS_PROD,
							new IStrategoTerm[]{
									Utilities.strategoListFromArray(list),
									_symbol.toATerm(),
									attrs
							},
							null,
							0
						),
						new StrategoInt(id(), null, 0)
				},
				null,
				0
				);
	}
	
	public static Production fromATerm(IStrategoTerm term, SymbolCollection symbols){
		if(term instanceof IStrategoAppl){
			StrategoAppl app = (StrategoAppl)term;
			boolean with_cons = false;
			if(app.getName().equals("SdfProduction") || (with_cons = true && app.getName().equals("SdfProductionWithCons"))){
				Symbol symbol;
				String cons = "";
				List<Symbol> sym_list = new ArrayList<>();
				StrategoAppl tattrs;
				
				if(with_cons){
					// SdfProductionWithCons(SortCons(<type>), Constructor("<cons>"), ...)
					symbol = Symbol.fromStrategoTerm(app.getSubterm(0).getSubterm(0), symbols);
					cons = ((StrategoString)app.getSubterm(0).getSubterm(1).getSubterm(0)).stringValue();
				}else{
					symbol = Symbol.fromStrategoTerm(app.getSubterm(0), symbols);
				}
				
				// Read right hand side of the equation: Rhs([<symbols>])
				StrategoList rhs = (StrategoList)app.getSubterm(1).getSubterm(0);
				for(IStrategoTerm t : rhs){
					sym_list.add(Symbol.fromStrategoTerm(t, symbols));
				}
				
				// Read attributes
				tattrs = (StrategoAppl)app.getSubterm(2);
				List<Attribute> attrs = new ArrayList<>();
				switch(tattrs.getName()){
				case "NoAttrs":
					break;
				case "Attrs": // TODO handle all production attributes
					StrategoList talist = (StrategoList)tattrs.getSubterm(0);
					for(IStrategoTerm ta : talist){
						StrategoAppl a = (StrategoAppl)ta;
						switch(a.getName()){
						case "Assoc":
							StrategoAppl assoc = (StrategoAppl)a.getSubterm(0);
							switch(assoc.getName()){
							case "Left":
								attrs.add(Attribute.ASSOC_LEFT);
								break;
							case "Right":
								attrs.add(Attribute.ASSOC_RIGHT);
								break;
							default:
								System.err.println("Unknown associativity: `"+assoc.getName()+"'.");
								break;
							}
							break;
						case "Bracket":
							attrs.add(Attribute.BRACKET);
							break;
						case "Reject":
							attrs.add(Attribute.REJECT);
							break;
						case "Term":
							ta = ta.getSubterm(0);
							if(ta instanceof StrategoAppl && ((StrategoAppl)ta).getName().equals("Default")){
								ta = ta.getSubterm(0);
								if(ta instanceof StrategoAppl && ((StrategoAppl)ta).getName().equals("Fun")){
									ta = ta.getSubterm(0);
									if(ta instanceof StrategoAppl && ((StrategoAppl)ta).getName().equals("Unquoted")){
										StrategoString str = (StrategoString)ta.getSubterm(0);
										if(str.stringValue().equals("longest-match")){
											attrs.add(Attribute.LONGEST_MATCH);
											break;
										}
									}
								}
							}
						default:
							System.err.println("Unknown attribute type: `"+a.getName()+"'.");
							break;
						}
					}
					break;
				default:
					System.err.println("Malformed Stratego term : Attributes expected.");
					return null;
				}
				
				return new Production(symbol, cons, sym_list, attrs);
			}
		}
		return null;
	}

	@Override
	public boolean isTerminal() {
		return false;
	}
}
